(*
    (\x.M) V                    -->M    M{V/x}
    let x <== return V in M     -->M    M{V/x}
    E[M1]                       -->M    E[M2]   (if M1  -->M  M2)

    E[give W a] || a(V^)        -->     E[return ()] || a(V^ ++ W)
    E[take a] || a(W ++ V^)     -->     E[return ()] || a(V^)
    E[fork M]                   -->     E[return ()] || M
    E[newCh]                    -->     va( E[return a] || a([]) )
    G[M1]                       -->     G[M2]   (if M1  -->M  M2)
    G[C1]                       -->     G[C2]   (if C1  -->   C2)
*)

type env := (procs, chans, vars)

(* Basics *********************************** *)

type literal =
| IntLit (int_lit)


type expr =
(* Integers *)
| Lit   (literal)
| Neg   (expr)
| Add   (expr, expr)
| Sub   (expr, expr)
| Mul   (expr, expr)
| Div   (expr, expr)

(* Unions *)
| Left  (expr)
| Right (expr)
| Match (expr, expr, expr)

(* Pairs *)
| Pair  (expr, expr)
| Fst   (expr)
| Snd   (expr)

(* Functions *)
| Var   (name)
| Func  (name, expr)
| Let   (name, expr, expr)
| Call  (expr, expr)
| Val   (value)

(* Concurrency *)
| NewCh
| Fork  (expr)
| Give  (expr)
| Take  (expr)


type any_value =
| UnitV
| IntV   (int_val)
| UnionV (union_val)
| PairV  (value, value)
| FuncV  (name, expr, env)

val eval ((state, expr) : (env, expr)) =
    (* ... *)


(* Integers ********************************* *)

type int_lit
type int_val

val int_of_lit : (int_lit)   -> (int_val)
val int_of_val : (any_val)   -> (int_val)

val neg : (int_val)          -> (any_val)
val add : (int_val, int_val) -> (any_val)
val sub : (int_val, int_val) -> (any_val)
val mul : (int_val, int_val) -> (any_val)
val div : (int_val, int_val) -> (any_val)

val reduce_neg ((state, expr) : (env, expr)) : (value) =
    branch
        let Neg (Val v) = expr in
        let i = int_of_val v in
        neg i
    or
        let Neg e = expr in
        let e' = reduce (state, e) in
        Neg e'
    end

val reduce_add ((state, expr) : (env, expr)) : (value) =
    branch
        let Add (Val u, Val v) = expr in
        let i = int_of_val u in
        let j = int_of_val v in
        add (i,j)
    or
        let Add (a, b) = expr in
        branch
            let a' = reduce (state, a) in
            Add (a', b)
        or
            let b' = reduce (state, a) in
            Add (a, b')
        end
    end

val eval_sub ((state, expr) : (env, expr)) : (value) =
    let Sub (a, b) = expr in
    let u = eval (state, a) in
    let v = eval (state, b) in
    let i = int_of_val u in
    let j = int_of_val v in
    sub (i,j)

val eval_mul ((state, expr) : (env, expr)) : (value) =
    let Mul (a, b) = expr in
    let u = eval (state, a) in
    let v = eval (state, b) in
    let i = int_of_val u in
    let j = int_of_val v in
    mul (i,j)

val eval_div ((state, expr) : (env, expr)) : (value) =
    let Div (a, b) = expr in
    let u = eval (state, a) in
    let v = eval (state, b) in
    let i = int_of_val u in
    let j = int_of_val v in
    div (i,j)


(* Unions *********************************** *)

type union_val =
| LeftV  (value)
| RightV (value)

val eval_match ((state, match_expr) : (env, expr)) : (value) =
    let Match (case, left, right) = match_expr in
    branch
        let LeftV value = eval (state, case) in
        let FuncV (var, body, state) = eval (state, left) in
        let state' = bind_name (var, value, state)
        eval (state', body)
    or
        let RightV value = eval (state, case) in
        let FuncV (var, body, state) = eval (state, right) in
        let state' = bind_name (var, value, state)
        eval (state', body)
    end


(* Pairs ************************************ *)

val eval_fst ((state, fst_expr) : (env, expr)) : (value) =
    let Fst content = fst_expr in
    eval (state, content)

val eval_snd ((state, snd_expr) : (env, expr)) : (value) =
    let Snd content = snd_expr in
    eval (state, content)


(* Functions ******************************** *)

val bind_name : (name, any_val, env) -> (env)
val read_name : (name, env)          -> (any_val)

val eval_var ((state, var_expr) : (env, expr)) : (value) =
    let Var var = var_expr in


| Var   (name)
| Func  (name, expr)
| Let   (name, expr, expr)
| Call  (expr, expr)
| Ret   (value)



(* Concurrency ****************************** *)

val eval_let

(* Skeletons ******************************** *)

(* Key                          *
 * s,z      : states            *
 * c,k      : configurations    *
 * e,a,b    : expressions       *
 * v,u,w    : values            *
 * l        : literal           *
 * i,j      : integers          *
 * f,g,h    : functions         *)

val eval_configs ((st, acc, rest): (state, config, config)) : (state, config) =
    branch
        let Nil = rest in ()
        (* Check for termination *)
        (* Recycle accumulator *)
    or
        let Cons (next, tail) = rest in
        branch
            let 
    end

(* List ************************************* *)

type list<a> =
| Nil
| Cons (a, list<a>)


val concat<a> (l: list<a>) (r: list<a>): (list<a>) =
    branch
        let Nil = l in
        r
    or
        let Cons (h, t) = l in
        let t' = concat t r in
        Cons (h, t')
    end

(* Queue ************************************ *)

type queue<a> = (list<a>, list<a>)

val topple<a> (q: queue<a>): (queue<a>) =
    let (inp, outp) = q in
    branch
        let Nil = inp in
        (Nil, outp)
    or
        let Cons (inp_h, inp_t) = inp in
        topple (inp_t, Cons (inp_h, outp))
    end

val enqueue<a> (q: queue<a>) (v: a): (queue<a>) =
    let (inp, outp) = q in
    (Cons (v, inp), outp)

val dequeue<a> (q: queue<a>) (v: a): (a, queue<a>) =
    let (inp, outp) = q in
    branch
        let Nil = outp in
        let (inp', outp') = topple (inp, Nil) in
        let Cons (outp'_h, outp'_t) = outp' in
        (outp'_h, (inp', outp'_t))
    or
        let Cons (outp_h, outp_t) = outp in
        (outp_h, (inp, outp_t))
    end
