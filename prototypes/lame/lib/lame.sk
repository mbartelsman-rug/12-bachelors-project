(* Types ------------------------------------ *)

type env

type name

type literal

type expr =
| Unit
| Seq   (expr, expr)
(* Lambda expressions *)
| Let   (name, expr, expr)
| Ret   (expr)
| Fun   (name, expr)
| App   (expr, expr)
| Var   (name)
(* Integer expressions *)
| Lit   (literal)
| Neg   (expr)
| Add   (expr, expr)
(* Product type expressions *)
| Pair  (expr, expr)
| Fst   (expr)
| Snd   (expr)
(* Sum type expressions *)
| True  (expr)
| False (expr)
| Match (expr, expr, expr)

type v_int

type v_either =
| VTrue   (value)
| VFalse  (value)

type value =
| VUnit
| VInt    (v_int)
| VEither (v_either)
| VPair   (value, value)
| VFun    (name, expr, env)


(* Filters ---------------------------------- *)

val env_write : (env, name, value) -> env
val env_read  : (env, name) -> value
val value_of_literal : literal -> value
val int_of_value : value -> v_int
val neg_int : (v_int) -> value
val add_int : (v_int, v_int) -> value


(* Skeletons -------------------------------- *)

val eval_unit ((_, e): (env, expr)) : (value) =
  let Unit = e in
  VUnit

val eval_seq ((s, e): (env, expr)) : (value) =
  let Seq (a, b) = e in
  eval (s, a) ;
  eval (s, b)

val eval_let ((s, e): (env, expr)) : (value) =
  let Let (n, v, b) = e in
  let v' = eval (s, v) in
  let s' = env_write (s, n, v') in
  eval (s', b)

(* Not sure if this is correct *)
val eval_ret ((s, e): (env, expr)) : (value) =
  let Ret (r) = e in
  eval (s, r)

val eval_fun ((s, e): (env, expr)) : (value) =
  let Fun (n, b) = e in
  VFun (n, b, s)

val eval_app ((s, e): (env, expr)) : (value) =
  let App (f, v) = e in
  let VFun (n, b, z) = eval (s, f) in
  let v' = eval (s, v) in
  let z' = env_write (z, n, v') in
  eval (z', b)

val eval_var ((s, e): (env, expr)) : (value) =
  let Var (n) = e in
  env_read (s, n)

val eval_lit ((_, e): (env, expr)) : (value) =
  let Lit (l) = e in
  value_of_literal l

val eval_neg ((s, e): (env, expr)) : (value) =
  let Neg (e') = e in
  let e'' = eval (s, e') in
  let i = int_of_value e'' in
  neg_int i

val eval_add ((s, e): (env, expr)) : (value) =
  let Add (a, b) = e in
  let a' = eval (s, a) in
  let b' = eval (s, b) in
  let i = int_of_value a' in
  let j = int_of_value b' in
  add_int (i, j)

val eval_pair ((s, e): (env, expr)) : (value) =
  let Pair (a, b) = e in
  let a' = eval (s, a) in
  let b' = eval (s, b) in
  VPair (a', b')

val eval_fst ((s, e): (env, expr)) : (value) =
  let Fst (p) = e in
  let VPair (fst, _) = eval (s, p) in
  fst

val eval_snd ((s, e): (env, expr)) : (value) =
  let Snd (p) = e in
  let VPair (_, snd) = eval (s, p) in
  snd

val eval_true ((s, e): (env, expr)) : (value) =
  let True (e') = e in
  let e'' = eval (s, e') in
  VEither (VTrue e'')

val eval_false ((s, e): (env, expr)) : (value) =
  let False (e') = e in
  let e'' = eval (s, e') in
  VEither (VFalse e'')

val eval_match ((s, e): (env, expr)) : (value) =
  let Match (g, on_t, on_f) = e in
  let VEither (g') = eval (s, g) in
  branch
    let VTrue (v) = g' in
    let VFun (n, b, z) = eval (s, on_t) in
    let z' = env_write (z, n, v) in
    eval (z', b)
  or
    let VFalse (v) = g' in
    let VFun (n, b, z) = eval (s, on_f) in
    let z' = env_write (z, n, v) in
    eval (z', b)
  end

val eval ((s, e): (env, expr)) : (value) =
  branch
    eval_unit (s, e)
  or
    eval_seq (s, e)
  or
    eval_let (s, e)
  or
    eval_ret (s, e)
  or
    eval_fun (s, e)
  or
    eval_app (s, e)
  or
    eval_var (s, e)
  or
    eval_lit (s, e)
  or
    eval_neg (s, e)
  or
    eval_add (s, e)
  or
    eval_pair (s, e)
  or
    eval_fst (s, e)
  or
    eval_snd (s, e)
  or
    eval_true (s, e)
  or
    eval_false (s, e)
  or
    eval_match (s, e)
  end
