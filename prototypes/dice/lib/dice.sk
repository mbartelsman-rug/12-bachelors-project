(* Base types *)

type lit
type ident
type state
type value


(* Program types *)

type stmt =
| Seq (stmt, stmt)
| Set (ident, expr)
| Roll (expr, expr)
| PNeg
| PAdd (expr)
| PGt  (expr)
| PTop (expr)
| Print (expr)
| Clear

type expr =
| Total
| Count
| Const (lit)
| Get (ident)
| Neg (expr)
| Add (expr, expr)


(* Filters *)

val litToVal    : lit -> value

val total       : state -> value
val count       : state -> value
val read        : (state, ident) -> value
val write       : (state, ident, value) -> state

val clear       : state -> state
val roll        : (state, value, value) -> state

val poolNeg     : state -> state
val poolAdd     : (state, value) -> state
val poolGt      : (state, value) -> state
val poolTop     : (state, value) -> state

val neg         : value -> value
val add         : (value, value) -> value

val print       : value -> ()


(* Skeletons *)

val eval_expr (s: state) (e:expr) : value =
    branch
        let Total = e in
        total s
    or
        let Count = e in
        count s
    or
        let Const l = e in
        litToVal l
    or
        let Get i = e in
        read (s, i)
    or
        let Neg a = e in
        let a' = eval_expr s a in
        neg a'
    or
        let Add (a, b) = e in
        let a' = eval_expr s a in
        let b' = eval_expr s b in
        add (a', b')
    end

val eval_stmt (s: state) (t: stmt) : state =
    branch
        let Seq (a, b) = t in
        let s' = eval_stmt s a in
        eval_stmt s' b
    or
        let Set (i, e) = t in
        let e' = eval_expr s e in
        write (s, i, e')
    or
        let Roll (n, z) = t in
        let n' = eval_expr s n in
        let z' = eval_expr s z in
        roll (s, n', z')
    or
        let PNeg = t in
        poolNeg s
    or
        let PAdd e = t in
        let e' = eval_expr s e in
        poolAdd (s, e')
    or
        let PGt e = t in
        let e' = eval_expr s e in
        poolGt (s, e')
    or
        let PTop e = t in
        let e' = eval_expr s e in
        poolTop (s, e')
    or
        let Print e = t in
        let e' = eval_expr s e in
        print e' ; s
    or
        let Clear = t in
        clear s
    end
