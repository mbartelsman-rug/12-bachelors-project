(* Types ************************************ *)

(* Environment storing name-value pairs *)
type env

(* Variable names *)
type name

(* Integer literals *)
type literal

(* Expressions *)
type expr =
| Unit
| Seq     (expr, expr)
(* Lambda expressions *)
| Let     (name, expr, expr)
| Ret     (expr)
| Fun     (name, expr)
| App     (expr, expr)
| Var     (name)
(* Integer expressions *)
| Lit     (literal)
| Neg     (expr)
| Add     (expr, expr)
(* Product type expressions *)
| Pair    (expr, expr)
| First   (expr)
| Second  (expr)
(* Sum type expressions *)
| Left    (expr)
| Right   (expr)
| Match   (expr, expr, expr)

(* Integer runtime value *)
type vint

(* Union runtime value *)
type vunion =
| VLeft   (value)
| VRight  (value)

(* Runtime value *)
type value =
| VUnit
| VInt    (vint)
| VUnion  (vunion)
| VPair   (value, value)
| VFun    (name, expr, env)


(* Filters ********************************** *)

(* Store a name-value pair into the
   environment *)
val env_store : (env, name, value) -> env

(* Retrieve the value associated with a name in
   the given enviornment *)
val env_get : (env, name) -> value

(* Convert a literal into a value *)
val value_of_literal : literal -> value

(* Assert that the value is an integer and
   convert it *)
val int_of_value : value -> vint

(* Negate the given integer *)
val neg_int : (vint) -> value

(* Add two integers *)
val add_int : (vint, vint) -> value


(* Skeletons ******************************** *)

(* Evaluate a unit-type constructor to a unit
   value *)
val eval_unit ((_, e): (env, expr)) : (value) =
  let Unit = e in
  VUnit

(* Evaluate a sequence of two expressions,
   discarding the return value of the first but
   preserving its environment *)
val eval_seq ((s, e): (env, expr)) : (value) =
  let Seq (a, b) = e in
  eval (s, a) ;
  eval (s, b)

(* Evaluate and bind the value to the name for
   the expression that follows. Called
   "Fine-grained call-by-value" in Fowler's
   paper *)
val eval_let ((s, e): (env, expr)) : (value) =
  let Let (n, v, b) = e in
  let v' = eval (s, v) in
  let s' = env_store (s, n, v') in
  eval (s', b)

(* Returns the given value.
   NOTE: Not sure if this is correct *)
val eval_ret ((s, e): (env, expr)) : (value) =
  let Ret (r) = e in
  eval (s, r)

(* Binds a function to its current environment,
   producing a closure value. *)
val eval_fun ((s, e): (env, expr)) : (value) =
  let Fun (n, b) = e in
  VFun (n, b, s)

(* Evaluates a function or closure with the
   provided values *)
val eval_app ((s, e): (env, expr)) : (value) =
  let App (f, v) = e in
  let VFun (n, b, z) = eval (s, f) in
  let v' = eval (s, v) in
  let z' = env_store (z, n, v') in
  eval (z', b)

(* Evaluates a variable name given the current
   environment *)
val eval_var ((s, e): (env, expr)) : (value) =
  let Var (n) = e in
  env_get (s, n)

(* Evaluates a literal into a value *)
val eval_lit ((_, e): (env, expr)) : (value) =
  let Lit (l) = e in
  value_of_literal l

(* Evaluates an integer negation *)
val eval_neg ((s, e): (env, expr)) : (value) =
  let Neg (e') = e in
  let e'' = eval (s, e') in
  let i = int_of_value e'' in
  neg_int i

(* Evaluates an integer addition *)
val eval_add ((s, e): (env, expr)) : (value) =
  let Add (a, b) = e in
  let a' = eval (s, a) in
  let b' = eval (s, b) in
  let i = int_of_value a' in
  let j = int_of_value b' in
  add_int (i, j)

(* Evaluates a pair constructor *)
val eval_pair ((s, e): (env, expr)) : (value) =
  let Pair (a, b) = e in
  let a' = eval (s, a) in
  let b' = eval (s, b) in
  VPair (a', b')

(* Returns the first value of a pair *)
val eval_first ((s, e): (env, expr)) : (value) =
  let First (p) = e in
  let VPair (fst, _) = eval (s, p) in
  fst

(* Returns the second value of a pair *)
val eval_second ((s, e): (env, expr)) : (value) =
  let Second (p) = e in
  let VPair (_, snd) = eval (s, p) in
  snd

(* Constructs a union with a "left" value *)
val eval_left ((s, e): (env, expr)) : (value) =
  let Left (e') = e in
  let e'' = eval (s, e') in
  VUnion (VLeft e'')

(* Constructs a union with a "right" value *)
val eval_right ((s, e): (env, expr)) : (value) =
  let Right (e') = e in
  let e'' = eval (s, e') in
  VUnion (VRight e'')

(* Evaluates a match over a union, branching
   left or right and applying the value to the
   corresponding function *)
val eval_match ((s, e): (env, expr)) : (value) =
  let Match (g, on_t, on_f) = e in
  let VUnion (g') = eval (s, g) in
  branch
    let VLeft (v) = g' in
    let VFun (n, b, z) = eval (s, on_t) in
    let z' = env_store (z, n, v) in
    eval (z', b)
  or
    let VRight (v) = g' in
    let VFun (n, b, z) = eval (s, on_f) in
    let z' = env_store (z, n, v) in
    eval (z', b)
  end

(* Top-level evaluation function *)
val eval ((s, e): (env, expr)) : (value) =
  branch
    eval_unit (s, e)
  or
    eval_seq (s, e)
  or
    eval_let (s, e)
  or
    eval_ret (s, e)
  or
    eval_fun (s, e)
  or
    eval_app (s, e)
  or
    eval_var (s, e)
  or
    eval_lit (s, e)
  or
    eval_neg (s, e)
  or
    eval_add (s, e)
  or
    eval_pair (s, e)
  or
    eval_first (s, e)
  or
    eval_second (s, e)
  or
    eval_left (s, e)
  or
    eval_right (s, e)
  or
    eval_match (s, e)
  end
