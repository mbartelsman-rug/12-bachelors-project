type program = mlterm

type ident
type globalcontext
type lit
type int
type env_option using env with join
type value_list using value with join

type localcontext = unit

type env1 = (ident, (ident program_point * globalcontext)) map
type env = env1 set
type clos = (ident program_point * mlterm program_point * env1) set
type constr = (ident program_point * globalcontext) set
type value = clos * int * constr

val envset : env1 * ident * (ident program_point * globalcontext) -> env1
val framepush : globalcontext * program_point -> globalcontext
val int_bot : unit -> int
val isBot : int -> int list
val intOfLit : lit -> int
val plus : int * int -> int
val isZero : localcontext * int -> localcontext list
val isNotZero : localcontext * int -> localcontext list
val mkNil : unit -> value_list
val mkCons : value * value_list -> value_list
val isNil : localcontext * value_list -> localcontext list
val isCons : value_list -> (value * value_list) list
val mkNone : unit -> env_option
val mkSome : env -> env_option
val isNone : localcontext * env_option -> localcontext list
val isSome : env_option -> env list
val sameName : ident * ident -> unit list

var vars : (ident program_point * globalcontext, value) map
(* Constructors are identified to their allocation site *)
var constrs : (ident program_point * globalcontext, value_list) map

rule in var eval : env
rule out var eval : value
rule in eval(pp, sigmas, env) = [((), env)]
rule out eval(pp, sigmas, sigma, v) = v
hook in eval(pp, sigmas, sigma, env, term_) = [(sigmas, env)]
hook out eval(pp, sigmas, sigma, result) = [(sigma, result)]
hook in eval^call(pp, sigmas, sigma, env, term_) = [(framepush(sigmas, pp), env)]
hook out eval^call(pp, sigmas, sigma, result) = [(sigma, result)]

rule in var eval_list : env
rule out var eval_list : value_list
rule in eval_list(pp, sigmas, env) = [((), env)]
rule out eval_list(pp, sigmas, sigma, v) = v
hook in eval_list(pp, sigmas, sigma, env, term_) = [(sigmas, env)]
hook out eval_list(pp, sigmas, sigma, result) = [(sigma, result)]

rule in var mlmatching : env * value
rule out var mlmatching : value
rule in mlmatching(pp, sigmas, envv) = let (env, v) = envv in [((), env, v)]
rule out mlmatching(pp, sigmas, sigma, v) = v
hook in mlmatching(pp, sigmas, sigma, env, v, term_) = [(sigmas, (env, v))]
hook out mlmatching(pp, sigmas, sigma, result) = [(sigma, result)]

rule in var pattern : env * value
rule out var pattern : env_option
rule in pattern(pp, sigmas, envv) = let (env, v) = envv in [((), env, v)]
rule out pattern(pp, sigmas, sigma, e) = e
hook in pattern(pp, sigmas, sigma, env, v, term_) = [(sigmas, (env, v))]
hook out pattern(pp, sigmas, sigma, result) = [(sigma, result)]

rule in var pattern_list : env * value_list
rule out var pattern_list : env_option
rule in pattern_list(pp, sigmas, envv) = let (env, v) = envv in [((), env, v)]
rule out pattern_list(pp, sigmas, sigma, e) = e
hook in pattern_list(pp, sigmas, sigma, env, v, term_) = [(sigmas, (env, v))]
hook out pattern_list(pp, sigmas, sigma, result) = [(sigma, result)]

filter mkClos(pp, sigmas, sigma, name, term_, env) =
  [(sigma, (join n in name, join t in term_, join e in env, {(n, t, e)}, int_bot (), {}))]
filter mkInt(pp, sigmas, sigma, x) =
  [(sigma, ({}, x, {}))]
filter getClos(pp, sigmas, sigma, value) =
  let (clos, _, _) = value in join (n, t, e) in clos, [(sigma, {n}, {t}, {e})]
filter getInt(pp, sigmas, sigma, value) =
  let (_, x, _) = value in join y in isBot(x), [(sigma, y)]

filter mkConstr(pp, sigmas, sigma, name, values) =
  [(sigma, ({}, int_bot (), join n in name, (values <= constrs[(n, sigmas)]) /\ {(n, sigmas)}))]
filter isConstrWithName(pp, sigmas, sigma, name, value) =
  let (_, _, c) = value in [(sigma, join n1 in name, join (n2, g) in c, join () in sameName(subterm(n1), subterm(n2)), constrs[(n2, g)])]
filter isNotConstrWithName(pp, sigmas, sigma, name, value) =
  (* Always true for now *)
  [sigma]

filter extEnv(pp, sigmas, sigma, env, name, value) =
  let sigmas1 = framepush(sigmas, pp) in
  [(sigma, join n in name, (value <= vars[(n, sigmas1)]) /\ join e in env, {envset(e, subterm(n), (n, sigmas1))})]
filter getEnv(pp, sigmas, sigma, name, env) =
  [(sigma, join n in name, join e in env, vars[e[subterm(n)]])]

filter intOfLit(pp, sigmas, sigma, x) =
  [(sigma, join pp1 in x, intOfLit(subterm(pp1)))]
filter plus(pp, sigmas, sigma, x1, x2) =
  [(sigma, plus(x1, x2))]
filter isZero(pp, sigmas, sigma, x) = isZero(sigma, x)
filter isNotZero(pp, sigmas, sigma, x) = isNotZero(sigma, x)

filter mkNil(pp, sigmas, sigma) = [(sigma, mkNil ())]
filter mkCons(pp, sigmas, sigma, value, values) = [(sigma, mkCons(value, values))]
filter isNil(pp, sigmas, sigma, values) = isNil(sigma, values)
filter isCons(pp, sigmas, sigma, values) = join (x, t) in isCons(values), [(sigma, x, t)]

filter mkNone(pp, sigmas, sigma) = [(sigma, mkNone ())]
filter mkSome(pp, sigmas, sigma, env) = [(sigma, mkSome(env))]
filter isNone(pp, sigmas, sigma, envopt) = isNone(sigma, envopt)
filter isSome(pp, sigmas, sigma, envopt) = join e in isSome(envopt), [(sigma, e)]

filter match_failure(pp, sigmas, sigma) = []
