type ident
type lit

type state
type value
type vint
type vbool
type vlist<a> =
| VNil
| VCons (a, vlist<a>)

type expr =
| Const lit
| Var ident
| Plus (expr, expr)
| Equal (expr, expr)
| Not expr

type stmt =
| Skip
| Assign (ident, expr)
| Seq (stmt, stmt)
| If (expr, stmt, stmt)
| While (expr, stmt)
| Parallel (stmt, stmt)

val litToVal : lit → value
val read : (ident, state) → value
val write : (ident, state, value) → state
val isInt : value → vint
val isBool : value → vbool
val add : vint → vint → value
val eq : vint → vint → value
val neg : vbool → value
val isTrue : vbool → ()
val isFalse : vbool → ()


val eval_expr (s:state) (e:expr): value =
	branch
		let Const i = e in
		litToVal (i)
	or
		let Var x = e in
		read (x, s)
	or
		let Plus (t1, t2) = e in
		let f1  = eval_expr s t1 in
		let f1' = isInt f1 in
		let f2  = eval_expr s t2 in
		let f2' = isInt f2 in
		add f1' f2'
	or
		let Equal (t1, t2) = e in
		let f1  = eval_expr s t1 in
		let f1' = isInt (f1) in
		let f2  = eval_expr s t2 in
		let f2' = isInt (f2) in
		eq f1' f2'
	or
		let Not t = e in
		let f1  = eval_expr s t in
		let f1' = isBool (f1) in
		neg (f1')
	end

val eval_stmt (s:state) (t:stmt): state =
	branch
		let Skip = t in
		s
	or
		let Assign (t1, t2) = t in
		let f2 = eval_expr s t2 in
		write (t1, s, f2)
	or
		let Seq (t1, t2) = t in
		let f1 = eval_stmt s t1 in
		eval_stmt f1 t2
	or
		let If (t1, t2, t3) = t in
		let f1  = eval_expr s t1 in
		let f1' = isBool (f1) in
		branch
			isTrue (f1') ;
			eval_stmt s t2
		or
			isFalse (f1') ;
			eval_stmt s t3
		end
	or
		let While (t1, t2) = t in
		let f1  = eval_expr s t1 in
		let f1' = isBool (f1) in
		branch
			isTrue (f1') ;
			let f2 = eval_stmt s t2 in
			eval_stmt f2 (While (t1, t2))
		or
			isFalse (f1') ;
			s
		end
	or
		let Parallel (Skip, Skip) = t in s
	or
		let Parallel(t1, t2) = t in
		branch
			let VCons(x1, q1) = flatten t1 in
			let t'1 = unflatten q1 in
			eval_stmt s (Seq(x1, Parallel(t'1, t2)))
		or
			let VCons(x2, q2) = flatten t2 in
			let t'2 = unflatten q2 in
			eval_stmt s (Seq(x2, Parallel(t1, t'2)))
		end
	end

val flatten (s:stmt): vlist<stmt> =
	branch
		let Skip = s in VNil<stmt>
	or
		branch
			let Assign _ = s in ()
		or
			let While _ = s in ()
		or
			let Parallel _ = s in ()
		or
			let If _ = s in ()
		end ;
		VCons<stmt> (s, VNil<stmt>)
	or
		let Seq (s1, s2) = s in
		let l1 = flatten s1 in
		let l2 = flatten s2 in
		append<stmt> l1 l2
	end

val unflatten (x:vlist<stmt>): stmt =
	branch
		let VNil = x in Skip
	or
		let VCons (x, q) = x in
		let t2 = unflatten q in
		Seq (x, t2)
	end

val append<a> (l1:vlist<a>) (l2:vlist<a>): vlist<a> =
	branch
		let VNil = l1 in l2
	or
		let VCons (x, q) = l1 in
		let l' = append<a> q l2 in
		VCons<a>(x, l')
	end
