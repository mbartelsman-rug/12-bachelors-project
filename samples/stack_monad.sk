(* State monad *)
type state
val bind<a,b> (a':(state → (a, state))) (f:(a → state → (b, state))) (s:state): (b, state) =
	let (a, new_state) = a' s in
	f a new_state
val ret<a> (a:a) (s:state): (a, state) = (a, s)


type literal

type value
type stack

type stmt =
| Skip
| Push literal
| Plus
| Minus
| Times
| Div
| Seq (stmt, stmt)

val add : value → value → value
val sub : value → value → value
val mul : value → value → value
val div : value → value → value
val litToVal : literal → value
val push : value → state → ((), state)
val pop : () → state → (value, state)

val eval (s:stmt): state → ((), state) =
	branch
		let Skip = s in
		ret<()> ()
	or
		let Push i = s in
		let f = litToVal (i) in
		push f
	or
		let Plus = s in
		let f1 =%bind pop () in
		let f2 =%bind pop () in
		let f3 = add f2 f1 in
		push f3
	or
		let Minus = s in
		let f1 =%bind pop () in
		let f2 =%bind pop () in
		let f3 = sub f2 f1 in
		push f3
	or
		let Times = s in
		let f1 =%bind pop () in
		let f2 =%bind pop () in
		let f3 = mul f2 f1 in
		push f3
	or
		let Div = s in
		let f1 =%bind pop () in
		let f2 =%bind pop () in
		let f3 = div f2 f1 in
		push f3
	or
		let Seq (t1, t2) = s in
		eval t1 ;%bind
		eval t2
	end
