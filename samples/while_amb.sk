(* implementing McCarthy's ambiguous operator *)

(* example:
 *
 * x := amb([1;2;3]) ;
 * y := amb([4;5;6]) ;
 * if (x*y != 8) then z:=amb([]) else skip
 *
 * will always output σ = {(x,2);(y,4)}
 * (at least once the OCaml interpreter works as intended) *)

type alist<a> =
| Nil
| Cons (a, alist<a>)

type ident
type lit

type state
type value
type vint
type vbool

type expr =
| Const lit
| Var ident
| Plus (expr, expr)
| Equal (expr, expr)
| Amb alist<expr>
| Not expr

type stmt =
| Skip
| Assign (ident, expr)
| Seq (stmt, stmt)
| If (expr, stmt, stmt)
| While (expr, stmt)

val litToVal : lit → value
val read : (ident, state) → value
val write : (ident, state, value) → state
val isInt : value → vint
val isBool : value → vbool
val add : (vint, vint) → value
val eq : (vint, vint) → value
val neg : vbool → value
val isTrue : vbool → ()
val isFalse : vbool → ()


val amb<a> (Cons (x, l):alist<a>): a =
	branch
		x
	or
		amb<a> (l)
	end

val eval_expr ((s,e):(state, expr)): value =
branch
	let Const i = e in
	litToVal (i)
or
	let Var x = e in
	read (x, s)
or
	let Plus (t1, t2) = e in
	let f1  = eval_expr (s, t1) in
	let f1' = isInt (f1) in
	let f2  = eval_expr (s, t2) in
	let f2' = isInt (f2) in
	add (f1', f2')
or
	let Equal (t1, t2) = e in
	let f1  = eval_expr (s, t1) in
	let f1' = isInt (f1) in
	let f2  = eval_expr (s, t2) in
	let f2' = isInt (f2) in
	eq (f1', f2')
or
	let Amb l = e in
	let x = amb<expr> l in
	eval_expr(s,x)
or
	let Not t = e in
	let f1  = eval_expr (s, t) in
	let f1' = isBool (f1) in
	neg (f1')
end

val eval_stmt ((s,t):(state, stmt)): state =
branch
	let Skip = t in
	s
or
	let Assign (t1, t2) = t in
	let f2 = eval_expr (s, t2) in
	write (t1, s, f2)
or
	let Seq (t1, t2) = t in
	let f1 = eval_stmt (s, t1) in
	eval_stmt (f1, t2)
or
	let If (t1, t2, t3) = t in
	let f1  = eval_expr (s, t1) in
	let f1' = isBool (f1) in
	branch
		isTrue (f1') ;
		eval_stmt (s, t2)
	or
		isFalse (f1') ;
		eval_stmt (s, t3)
	end
or
	let While (t1, t2) = t in
	let f1  = eval_expr (s, t1) in
	let f1' = isBool (f1) in
	branch
		isTrue (f1') ;
		let f2 = eval_stmt (s, t2) in
		eval_stmt (f2, While (t1, t2))
	or
		isFalse (f1') ;
		s
	end
end

