type ident
type lit

type state
type value
type vint
type vbool

type expr =
| Const lit
| Var ident
| Plus (expr, expr)
| Equal (expr, expr)
| Not expr
| Value value

type stmt =
| Skip
| Assign (ident, expr)
| Seq (stmt, stmt)
| If (expr, stmt, stmt)
| While (expr, stmt)
| While2 (expr, expr, stmt)
| Parallel (stmt, stmt)

val litToVal : lit → value
val read : (ident, state) → value
val write : (ident, state, value) → state
val isInt : value → vint
val isBool : value → vbool
val add : (vint, vint) → value
val eq : (vint, vint) → value
val neg : vbool → value
val isTrue : vbool → ()
val isFalse : vbool → ()


val eval_expr (s:state) (e:expr): expr =
	branch
		let Const i = e in
		let v = litToVal (i) in
		Value v
	or
		let Var x = e in
		let v = read (x, s) in
		Value v
	or
		let Plus (Value v1, Value v2) = e in
		let i1 = isInt v1 in
		let i2 = isInt v2 in
		let v = add (i1, i2) in
		Value v
	or
		let Plus (t1, t2) = e in
		branch
			let t'1 = eval_expr s t1 in
			Plus(t'1, t2)
		or
			let t'2 = eval_expr s t2 in
			Plus(t1, t'2)
		end
	or
		let Equal (Value v1, Value v2) = e in
		let i1 = isInt v1 in
		let i2 = isInt v2 in
		let v = eq (i1, i2) in
		Value v
	or
		let Equal (t1, t2) = e in
		branch
			let t'1 = eval_expr s t1 in
			Equal (t'1, t2)
		or
			let t'2 = eval_expr s t2 in
			Equal (t1, t'2)
		end
	or
		let Not (Value v) = e in
		let b = isBool v in
		let b' = neg b in
		Value b'
	or
		let Not t = e in
		let t' = eval_expr s t in
		Not t'
	end

val eval_stmt (s:state) (t:stmt): (state, stmt) =
branch
	let Assign (x, Value v) = t in
	let s' = write (x, s, v) in
	(s', Skip)
or
	let Assign (x, t) = t in
	let t' = eval_expr s t in
	(s, Assign (x, t'))
or
	let Seq (Skip, t2) = t in
	(s, t2)
or
	let Seq (t1, t2) = t in
	let (s', t'1) = eval_stmt s t1 in
	(s', Seq (t'1, t2))
or
	let If (Value e, iftrue, iffalse) = t in
	let b = isBool e in
	branch
		isTrue b ;
		(s, iftrue)
	or
		isFalse b ;
		(s, iffalse)
	end
or
	let If (e, iftrue, iffalse) = t in
	let e' = eval_expr s e in
	(s, If (e', iftrue, iffalse))
or
	let While (e, t) = t in
	(s, While2 (e, e, t))
or
	let While2 (Value v, e, t) = t in
	let b = isBool v in
	branch
		isTrue b ;
		(s, Seq (t, While(e, t)))
	or
		isFalse b ;
		(s, Skip)
	end
or
	let While2 (e1, e2, t) = t in
	let e'1 = eval_expr s e1 in
	(s, While2 (e'1, e2, t))
or
	let Parallel (Skip, Skip) = t in
	(s, Skip)
or
	let Parallel (t1, t2) = t in
	let (s', t'1) = eval_stmt s t1 in
	(s', Parallel(t'1, t2))
or
	let Parallel (t1, t2) = t in
	let (s', t'2) = eval_stmt s t2 in
	(s', Parallel(t1, t'2))
end

