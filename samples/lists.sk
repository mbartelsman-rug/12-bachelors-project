type boolean =
| True | False

val andb (b1:boolean) (b2:boolean): boolean =
	branch
		let False = b1 in False
	or
		let True = b1 in b2
	end

val orb (b1:boolean) (b2:boolean): boolean =
	branch
		let True = b1 in True
	or
		let False = b1 in b2
	end




type list<a> =
| Nil | Cons (a, list<a>)



type option<a> =
| None | Some a

val unfold<a> (l:list<option<a>>): option<list<a>> =
	branch
		let Nil = l in
		Some<list<a>> Nil<a>
	or
		let Cons (x, q) = l in
		let q = unfold<a> (q) in
		branch
			let None = x in
			None<list<a>>
		or
			let None = q in
			None<list<a>>
		or
			let Some x = x in
			let Some q = q in
			let l' = Cons<a>(x, q) in
			Some<list<a>> l'
		end
	end

val append<a> (l1:list<a>) (l2:list<a>): list<a> =
	branch
		let Nil = l1 in l2
	or
		let Cons (x, q) = l1 in
		let aux = append<a> q l2 in
		Cons<a> (x, aux)
	end

val flatten<a> (l:list<list<a>>): list<a> =
	branch
		let Nil = l in Nil<a>
	or
		let Cons (x, q) = l in
		let aux = flatten<a> q in
		append<a> x aux
	end



val iter<a> (f:a → ()) (l:list<a>): () =
	branch
		let Nil = l in ()
	or
		let Cons (x, q) = l in
		let () = f x in
		iter<a> f q
	end

val map<a, b> (f:a → b) (l:list<a>): list<b> =
	branch
		let Nil = l in Nil<b>
	or
		let Cons (x, q) = l in
		let x' = f x in
		let q' = map<a, b> f q in
		Cons<b> (x', q')
	end

val filter<a> (f:a → boolean) (l:list<a>): list<a> =
	branch
		let Nil = l in
		Nil<a>
	or
		let Cons (x, q) = l in
		let False = f x in
		filter<a> f q
	or
		let Cons (x, q) = l in
		let True = f x in
		let q' = filter<a> f q in
		Cons<a> (x, q')
	end

val fold_left<a, b> (f:a → b → a) (a:a) (l:list<b>): a =
	branch
		let Nil = l in a
	or
		let Cons (x, q) = l in
		let a' = f a x in
		fold_left<a, b> f a' q
	end






val for_all<a> (f:(a → boolean)) (l:list<a>): boolean =
	branch
		let Nil = l in True
	or
		let Cons (x, q) = l in
		let b = f x in
		let b' = for_all<a> f q in
		andb b b'
	end

val exists<a> (f:(a → boolean)) (l:list<a>): boolean =
	branch
		let Nil = l in False
	or
		let Cons (x, q) = l in
		let b = f x in
		let b' = exists<a> f q in
		orb b b'
	end

val find_first_opt<a> (f:(a → boolean)) (l:list<a>): option<a> =
	branch
		let Nil = l in None<a>
	or
		let Cons (x, _) = l in
		let True = f x in
		Some<a> x
	or
		let Cons (x, q) = l in
		let False = f x in
		find_first_opt<a> f q
	end

val find_first<a> (f:(a → boolean)) (l:list<a>): a =
	let Some x = find_first_opt<a> f l in x

val find_opt<a> (f:(a → boolean)) (l:list<a>): option<a> =
	branch
		let Nil = l in
		None<a>
	or
		let Cons (x, _) = l in
		let True = f x in
		Some<a> x
	or
		let Cons (_, q) = l in
		let Some y = find_opt<a> f q in
		Some<a> y
	or
		let Cons (x, q) = l in
		let None = find_opt<a> f q in
		let False = f x in
		None<a>
	end

val find<a> (f:(a → boolean)) (l:list<a>): a =
	let Some x = find_opt<a> f l in x



val insert<a> (le:(a → a → boolean)) (x:a) (l:list<a>): list<a> =
	branch
		let Nil = l in
		Cons<a> (x, Nil<a>)
	or
		let Cons (y, q) = l in
		let cmp = le x y in
		branch
			let True = cmp in
			Cons<a> (x, Cons<a> (y, q))
		or
			let False = cmp in
			let aux = insert<a> le x q in
			Cons<a> (y, aux)
		end
	end


(* [sort (f, l)] sorts [l] for the < order given by [f] *)
val sort<a> (le:(a → a → boolean)) (l:list<a>): list<a> =
	branch
		let Nil = l in
		l
	or
		let Cons (x, q) = l in
		let aux = sort<a> le q in
		insert<a> le x aux
	end






val split<a, b> (l:list<(a, b)>): (list<a>, list<b>) =
	branch
		let Nil = l in
		(Nil<a>, Nil<b>)
	or
		let Cons ((x1, x2), q) = l in
		let (aux1, aux2) = split<a,b> q in
		(Cons<a> (x1, aux1), Cons<b> (x2, aux2))
	end

val combine<a, b> (la:list<a>) (lb:list<b>): list<(a, b)> =
	branch
		let (Nil, Nil) = (la, lb) in
		(Nil<(a,b)>)
	or
		let (Cons (xa, qa), Cons (xb, qb)) = (la, lb) in
		let aux = combine<a,b> qa qb in
		Cons<(a,b)> ((xa, xb), aux)
	end


