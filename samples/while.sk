type ident
type lit

type state
type value
type vint
type vbool

type expr =
| Const lit
| Var ident
| Plus (expr, expr)
| Equal (expr, expr)
| Not expr

type stmt =
| Skip
| Assign (ident, expr)
| Seq (stmt, stmt)
| If (expr, stmt, stmt)
| While (expr, stmt)

val litToVal : lit → value
val read : ident → state → value
val write : ident → state → value → state
val isInt : value → vint
val isBool : value → vbool
val add : vint → vint → value
val eq : vint → vint → value
val neg : vbool → value
val isTrue : vbool → ()
val isFalse : vbool → ()


val eval_expr (s:state) (e:expr): value =
branch
	let Const i = e in
	litToVal i
or
	let Var x = e in
	read x s
or
	let Plus (t1, t2) = e in
	let f1 = eval_expr s t1 in
	let i1 = isInt f1 in
	let f2 = eval_expr s t2 in
	let i2 = isInt f2 in
	add i1 i2
or
	let Equal (t1, t2) = e in
	let f1 = eval_expr s t1 in
	let i1 = isInt f1 in
	let f2 = eval_expr s t2 in
	let i2 = isInt f2 in
	eq i1 i2
or
	let Not e = e in
	let f1 = eval_expr s e in
	let b = isBool f1 in
	neg b
end

val eval_stmt (s:state) (t:stmt): state =
branch
	let Skip = t in
	s
or
	let Assign (x, e) = t in
	let v = eval_expr s e in
	write x s v
or
	let Seq (t1, t2) = t in
	let s' = eval_stmt s t1 in
	eval_stmt s' t2
or
	let If (cond, true, false) = t in
	let f1 = eval_expr s cond in
	let b = isBool f1 in
	branch
		isTrue b ;
		eval_stmt s true 
	or
		isFalse b ;
		eval_stmt s false
	end
or
	let While (cond, t') = t in
	let f1 = eval_expr s cond in
	let b = isBool f1 in
	branch
		isTrue b ;
		let s' = eval_stmt s t' in
		eval_stmt s' t
	or
		isFalse b ;
		s
	end
end

