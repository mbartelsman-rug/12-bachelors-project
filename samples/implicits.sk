(* This example aims at showing how to represent non-syntactic operations like implicit type coercions in skeletons through non-matching hooks. *)

type ident
type lit

type state
type value
type vint
type vbool

type expr =
| Const lit
| Var ident
| Plus (expr, expr)
| Equal (expr, expr)
| Not expr

type stmt =
| Skip
| Assign (ident, expr)
| Seq (stmt, stmt)
| If (expr, stmt, stmt)
| While (expr, stmt)

val litToVal : lit → value
val read : (ident, state) → value
val write : (ident, state, value) → state

val mkInt : vint → value
val isInt : value → vint
val zero : vint
val one : vint
val add : (vint, vint) → vint
val eq : (vint, vint) → ()
val neq : (vint, vint) → ()

val mkBool : vbool → value
val isBool : value → vbool
val true : vbool
val false : vbool
val isTrue : vbool → ()
val isFalse : vbool → ()

val toInteger (v:value): vint =
	branch
		let i = isInt (v) in
		i
	or
		let b = isBool (v) in
		branch
			isTrue (b) ;
			one
		or
			isFalse (b) ;
			zero
		end
	end

val toBoolean (v:value): vbool =
	branch
		let b = isBool (v) in
		b
	or
		let i = isInt (v) in
		let z = zero in
		branch
			eq (i, z) ;
			false
		or
			neq (i, z) ;
			true
		end
	end

val neg (b:vbool): vbool =
	branch
		isTrue (b) ;
		false
	or
		isFalse (b) ;
		true
	end

val eqBoolean  (b1:vbool) (b2:vbool): vbool =
	branch
		isTrue b1;
		b2
	or
		isFalse b1;
		neg b2
	end

val eval_expr (s:state) (e:expr): value =
	branch
		let Const i = e in
		litToVal (i)
	or
		let Var x = e in
		read (x, s)
	or
		let Plus (t1, t2) = e in
		let v1  = eval_expr s t1 in
		let v1 = toInteger (v1) in
		let v2  = eval_expr s t2 in
		let v2 = toInteger (v2) in
		let v3 = add (v1, v2) in
		mkInt (v3)
	or
		let Equal (t1, t2) = e in
		let v1  = eval_expr s t1 in
		let v2  = eval_expr s t2 in
		let b =
			(* We add the implicits as follows:
				if both values are booleans, then they are compared as-is.
				Otherwise, they are both converted to an integer and compared as-is. *)
			branch
				let b1 = isBool (v1) in
				let b2 = isBool (v2) in
				eqBoolean b1 b2
			or
				let (i1, i2) =
					branch
						let i1 = isInt (v1) in
						let i2 = toInteger (v2) in
						(i1, i2)
					or
						let i1 = toInteger (v1) in
						let i2 = isInt (v2) in
						(i1, i2)
					end in
				branch
					eq (i1, i2) ;
					true
				or
					neq (i1, i2) ;
					false
				end
			end in
		mkBool b
	or
		let Not t = e in
		let v  = eval_expr s t in
		let b = toBoolean (v) in
		let n = neg (b) in
		mkBool (n)
	end

val eval_stmt (s:state) (t:stmt): state =
	branch
		let Skip = t in
		s
	or
		let Assign (x, e) = t in
		let v = eval_expr s e in
		write (x, s, v)
	or
		let Seq (t1, t2) = t in
		let s = eval_stmt s t1 in
		eval_stmt s t2
	or
		let If (e, t1, t2) = t in
		let v = eval_expr s e in
		let b = toBoolean (v) in
		branch
			isTrue (b) ;
			eval_stmt s t1
		or
			isFalse (b) ;
			eval_stmt s t2
		end
	or
		let While (e, t) = t in
		let v = eval_expr s e in
		let b = toBoolean (v) in
		branch
			isTrue (b) ;
			let s = eval_stmt s t in
			eval_stmt s t
		or
			isFalse (b) ;
			s
		end
	end

