type ident
type lit
type state
type vint

type boolean =
| True | False

type value =
| Int vint | Bool boolean

type expr =
| Const lit
| Var ident
| Plus (expr, expr)
| Equal (expr, expr)
| Not expr

type stmt =
| Skip
| Assign (ident, expr)
| Seq (stmt, stmt)
| If (expr, stmt, stmt)
| While (expr, stmt)

val litToVal : lit → value
val read : ident → state → value
val write : ident → state → value → state
val add : vint → vint → vint
val eq : vint → vint → boolean

val neg (b:boolean): boolean =
	branch
		let True = b in False
	or
		let False = b in True
	end

val eval_expr (s:state) (e:expr): value =
branch
	let Const i = e in
	litToVal i
or
	let Var x = e in
	read x s
or
	let Plus (e1, e2) = e in
	let Int v1 = eval_expr s e1 in
	let Int v2 = eval_expr s e2 in
	let v = add v1 v2 in
	Int v
or
	let Equal (e1, e2) = e in
	let Int v1 = eval_expr s e1 in
	let Int v2 = eval_expr s e2 in
	let v = eq v1 v2 in
	Bool v
or
	let Not f = e in
	let Bool w = eval_expr s f in
	let v = neg w in
	Bool v
end

val eval_stmt (s:state) (t:stmt): state  =
branch
	let Skip = t in
	s
or
	let Assign (x, e) = t in
	let w = eval_expr s e in
	write x s w
or
	let Seq (t1, t2) = t in
	let s' = eval_stmt s t1 in
	eval_stmt s' t2
or
	let If (cond, true, false) = t in
	let Bool b = eval_expr s cond in
	branch
		let True = b in
		eval_stmt s true
	or
		let False = b in
		eval_stmt s false
	end
or
	let While (cond, t') = t in
	let Bool b = eval_expr s cond in
	branch
		let True = b in
		let s' = eval_stmt s t' in
		eval_stmt s' (While (cond, t'))
	or
		let False = b in
		s
	end
end
